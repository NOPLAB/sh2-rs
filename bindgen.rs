/* automatically generated by rust-bindgen 0.69.4 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const SH2_HAL_MAX_TRANSFER_OUT: u32 = 128;
pub const SH2_HAL_MAX_PAYLOAD_OUT: u32 = 128;
pub const SH2_HAL_MAX_TRANSFER_IN: u32 = 1024;
pub const SH2_HAL_MAX_PAYLOAD_IN: u32 = 1024;
pub const SH2_MAX_SENSOR_EVENT_LEN: u32 = 60;
pub const SH2_MAX_PROD_ID_ENTRIES: u32 = 5;
pub const STATIC_CALIBRATION_AGM: u32 = 31097;
pub const NOMINAL_CALIBRATION: u32 = 19789;
pub const STATIC_CALIBRATION_SRA: u32 = 35466;
pub const NOMINAL_CALIBRATION_SRA: u32 = 20046;
pub const DYNAMIC_CALIBRATION: u32 = 7967;
pub const ME_POWER_MGMT: u32 = 54242;
pub const SYSTEM_ORIENTATION: u32 = 11582;
pub const ACCEL_ORIENTATION: u32 = 11585;
pub const SCREEN_ACCEL_ORIENTATION: u32 = 11587;
pub const GYROSCOPE_ORIENTATION: u32 = 11590;
pub const MAGNETOMETER_ORIENTATION: u32 = 11596;
pub const ARVR_STABILIZATION_RV: u32 = 15917;
pub const ARVR_STABILIZATION_GRV: u32 = 15918;
pub const TAP_DETECT_CONFIG: u32 = 49769;
pub const SIG_MOTION_DETECT_CONFIG: u32 = 49780;
pub const SHAKE_DETECT_CONFIG: u32 = 32125;
pub const MAX_FUSION_PERIOD: u32 = 55255;
pub const SERIAL_NUMBER: u32 = 19275;
pub const ES_PRESSURE_CAL: u32 = 14767;
pub const ES_TEMPERATURE_CAL: u32 = 19744;
pub const ES_HUMIDITY_CAL: u32 = 6857;
pub const ES_AMBIENT_LIGHT_CAL: u32 = 14769;
pub const ES_PROXIMITY_CAL: u32 = 19874;
pub const ALS_CAL: u32 = 54273;
pub const PROXIMITY_SENSOR_CAL: u32 = 54274;
pub const PICKUP_DETECTOR_CONFIG: u32 = 6954;
pub const FLIP_DETECTOR_CONFIG: u32 = 64660;
pub const STABILITY_DETECTOR_CONFIG: u32 = 60805;
pub const ACTIVITY_TRACKER_CONFIG: u32 = 60808;
pub const SLEEP_DETECTOR_CONFIG: u32 = 60807;
pub const TILT_DETECTOR_CONFIG: u32 = 60809;
pub const POCKET_DETECTOR_CONFIG: u32 = 61223;
pub const CIRCLE_DETECTOR_CONFIG: u32 = 61009;
pub const USER_RECORD: u32 = 29876;
pub const ME_TIME_SOURCE_SELECT: u32 = 54275;
pub const UART_FORMAT: u32 = 41377;
pub const GYRO_INTEGRATED_RV_CONFIG: u32 = 41378;
pub const DR_IMU_CONFIG: u32 = 57042;
pub const DR_VEL_EST_CONFIG: u32 = 57043;
pub const DR_SYNC_CONFIG: u32 = 57044;
pub const DR_QUAL_CONFIG: u32 = 57045;
pub const DR_CAL_CONFIG: u32 = 57046;
pub const DR_LIGHT_REC_CONFIG: u32 = 57048;
pub const DR_FUSION_CONFIG: u32 = 57049;
pub const DR_OF_CONFIG: u32 = 57050;
pub const DR_WHEEL_CONFIG: u32 = 57051;
pub const DR_CAL: u32 = 57052;
pub const DR_WHEEL_SELECT: u32 = 57055;
pub const FRS_ID_META_RAW_ACCELEROMETER: u32 = 58113;
pub const FRS_ID_META_ACCELEROMETER: u32 = 58114;
pub const FRS_ID_META_LINEAR_ACCELERATION: u32 = 58115;
pub const FRS_ID_META_GRAVITY: u32 = 58116;
pub const FRS_ID_META_RAW_GYROSCOPE: u32 = 58117;
pub const FRS_ID_META_GYROSCOPE_CALIBRATED: u32 = 58118;
pub const FRS_ID_META_GYROSCOPE_UNCALIBRATED: u32 = 58119;
pub const FRS_ID_META_RAW_MAGNETOMETER: u32 = 58120;
pub const FRS_ID_META_MAGNETIC_FIELD_CALIBRATED: u32 = 58121;
pub const FRS_ID_META_MAGNETIC_FIELD_UNCALIBRATED: u32 = 58122;
pub const FRS_ID_META_ROTATION_VECTOR: u32 = 58123;
pub const FRS_ID_META_GAME_ROTATION_VECTOR: u32 = 58124;
pub const FRS_ID_META_GEOMAGNETIC_ROTATION_VECTOR: u32 = 58125;
pub const FRS_ID_META_PRESSURE: u32 = 58126;
pub const FRS_ID_META_AMBIENT_LIGHT: u32 = 58127;
pub const FRS_ID_META_HUMIDITY: u32 = 58128;
pub const FRS_ID_META_PROXIMITY: u32 = 58129;
pub const FRS_ID_META_TEMPERATURE: u32 = 58130;
pub const FRS_ID_META_TAP_DETECTOR: u32 = 58131;
pub const FRS_ID_META_STEP_DETECTOR: u32 = 58132;
pub const FRS_ID_META_STEP_COUNTER: u32 = 58133;
pub const FRS_ID_META_SIGNIFICANT_MOTION: u32 = 58134;
pub const FRS_ID_META_STABILITY_CLASSIFIER: u32 = 58135;
pub const FRS_ID_META_SHAKE_DETECTOR: u32 = 58136;
pub const FRS_ID_META_FLIP_DETECTOR: u32 = 58137;
pub const FRS_ID_META_PICKUP_DETECTOR: u32 = 58138;
pub const FRS_ID_META_STABILITY_DETECTOR: u32 = 58139;
pub const FRS_ID_META_PERSONAL_ACTIVITY_CLASSIFIER: u32 = 58140;
pub const FRS_ID_META_SLEEP_DETECTOR: u32 = 58141;
pub const FRS_ID_META_TILT_DETECTOR: u32 = 58142;
pub const FRS_ID_META_POCKET_DETECTOR: u32 = 58143;
pub const FRS_ID_META_CIRCLE_DETECTOR: u32 = 58144;
pub const FRS_ID_META_HEART_RATE_MONITOR: u32 = 58145;
pub const FRS_ID_META_ARVR_STABILIZED_RV: u32 = 58146;
pub const FRS_ID_META_ARVR_STABILIZED_GRV: u32 = 58147;
pub const FRS_ID_META_GYRO_INTEGRATED_RV: u32 = 58148;
pub const FRS_ID_META_RAW_OPTICAL_FLOW: u32 = 58150;
pub const SH2_CAL_ACCEL: u32 = 1;
pub const SH2_CAL_GYRO: u32 = 2;
pub const SH2_CAL_MAG: u32 = 4;
pub const SH2_CAL_PLANAR: u32 = 8;
pub const SH2_CAL_ON_TABLE: u32 = 16;
pub const SH2_CAL_ZERO_GYRO_CONTROL_MASK: u32 = 96;
pub const SH2_CAL_ZERO_GYRO_CONTROL_ON_TABLE_DETECT: u32 = 0;
pub const SH2_CAL_ZERO_GYRO_CONTROL_NEVER: u32 = 32;
pub const SH2_CAL_ZERO_GYRO_CONTROL_ON_TABLE_CLASS: u32 = 64;
pub const SH2_CAL_ZERO_GYRO_CONTROL_ON_TABLE_CLASS_OR_LONG_TERM_STABLE: u32 = 96;
pub const TAPDET_X: u32 = 1;
pub const TAPDET_X_POS: u32 = 2;
pub const TAPDET_Y: u32 = 4;
pub const TAPDET_Y_POS: u32 = 8;
pub const TAPDET_Z: u32 = 16;
pub const TAPDET_Z_POS: u32 = 32;
pub const TAPDET_DOUBLE: u32 = 64;
pub const STABILITY_CLASSIFIER_UNKNOWN: u32 = 0;
pub const STABILITY_CLASSIFIER_ON_TABLE: u32 = 1;
pub const STABILITY_CLASSIFIER_STATIONARY: u32 = 2;
pub const STABILITY_CLASSIFIER_STABLE: u32 = 3;
pub const STABILITY_CLASSIFIER_MOTION: u32 = 4;
pub const SHAKE_X: u32 = 1;
pub const SHAKE_Y: u32 = 2;
pub const SHAKE_Z: u32 = 4;
pub const PICKUP_LEVEL_TO_NOT_LEVEL: u32 = 1;
pub const PICKUP_STOP_WITHIN_REGION: u32 = 2;
pub const STABILITY_ENTERED: u32 = 1;
pub const STABILITY_EXITED: u32 = 2;
pub const PAC_UNKNOWN: u32 = 0;
pub const PAC_IN_VEHICLE: u32 = 1;
pub const PAC_ON_BICYCLE: u32 = 2;
pub const PAC_ON_FOOT: u32 = 3;
pub const PAC_STILL: u32 = 4;
pub const PAC_TILTING: u32 = 5;
pub const PAC_WALKING: u32 = 6;
pub const PAC_RUNNING: u32 = 7;
pub const SH2_OK: u32 = 0;
pub const SH2_ERR: i32 = -1;
pub const SH2_ERR_BAD_PARAM: i32 = -2;
pub const SH2_ERR_OP_IN_PROGRESS: i32 = -3;
pub const SH2_ERR_IO: i32 = -4;
pub const SH2_ERR_HUB: i32 = -5;
pub const SH2_ERR_TIMEOUT: i32 = -6;
pub type va_list = *mut ::core::ffi::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::core::ffi::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::core::ffi::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::core::ffi::c_schar;
pub type int_least16_t = ::core::ffi::c_short;
pub type int_least32_t = ::core::ffi::c_int;
pub type int_least64_t = ::core::ffi::c_longlong;
pub type uint_least8_t = ::core::ffi::c_uchar;
pub type uint_least16_t = ::core::ffi::c_ushort;
pub type uint_least32_t = ::core::ffi::c_uint;
pub type uint_least64_t = ::core::ffi::c_ulonglong;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_int;
pub type int_fast32_t = ::core::ffi::c_int;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_uint;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub type sh2_Hal_t = sh2_Hal_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Hal_s {
    pub open:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut sh2_Hal_t) -> ::core::ffi::c_int>,
    pub close: ::core::option::Option<unsafe extern "C" fn(self_: *mut sh2_Hal_t)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut sh2_Hal_t,
            pBuffer: *mut u8,
            len: ::core::ffi::c_uint,
            t_us: *mut u32,
        ) -> ::core::ffi::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut sh2_Hal_t,
            pBuffer: *mut u8,
            len: ::core::ffi::c_uint,
        ) -> ::core::ffi::c_int,
    >,
    pub getTimeUs: ::core::option::Option<unsafe extern "C" fn(self_: *mut sh2_Hal_t) -> u32>,
}
#[test]
fn bindgen_test_layout_sh2_Hal_s() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Hal_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Hal_s>(),
        40usize,
        concat!("Size of: ", stringify!(sh2_Hal_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Hal_s>(),
        8usize,
        concat!("Alignment of ", stringify!(sh2_Hal_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getTimeUs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Hal_s),
            "::",
            stringify!(getTimeUs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorEvent {
    pub timestamp_uS: u64,
    pub delay_uS: i64,
    pub len: u8,
    pub reportId: u8,
    pub report: [u8; 60usize],
}
#[test]
fn bindgen_test_layout_sh2_SensorEvent() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SensorEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorEvent>(),
        80usize,
        concat!("Size of: ", stringify!(sh2_SensorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(sh2_SensorEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp_uS) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(timestamp_uS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay_uS) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(delay_uS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reportId) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(reportId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).report) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorEvent),
            "::",
            stringify!(report)
        )
    );
}
pub type sh2_SensorEvent_t = sh2_SensorEvent;
pub type sh2_SensorCallback_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut ::core::ffi::c_void, pEvent: *mut sh2_SensorEvent_t),
>;
#[doc = " @brief Product Id value\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ProductId_s {
    pub resetCause: u8,
    pub swVersionMajor: u8,
    pub swVersionMinor: u8,
    pub swPartNumber: u32,
    pub swBuildNumber: u32,
    pub swVersionPatch: u16,
    pub reserved0: u8,
    pub reserved1: u8,
}
#[test]
fn bindgen_test_layout_sh2_ProductId_s() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_ProductId_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_ProductId_s>(),
        16usize,
        concat!("Size of: ", stringify!(sh2_ProductId_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ProductId_s>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_ProductId_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resetCause) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(resetCause)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swVersionMajor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swVersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swVersionMinor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swVersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swPartNumber) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swPartNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swBuildNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swBuildNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swVersionPatch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(swVersionPatch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductId_s),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " @brief Product Id value\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_ProductId_t = sh2_ProductId_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ProductIds_s {
    pub entry: [sh2_ProductId_t; 5usize],
    pub numEntries: u8,
}
#[test]
fn bindgen_test_layout_sh2_ProductIds_s() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_ProductIds_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_ProductIds_s>(),
        84usize,
        concat!("Size of: ", stringify!(sh2_ProductIds_s))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ProductIds_s>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_ProductIds_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductIds_s),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numEntries) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ProductIds_s),
            "::",
            stringify!(numEntries)
        )
    );
}
pub type sh2_ProductIds_t = sh2_ProductIds_s;
pub const sh2_SensorId_e_SH2_RAW_ACCELEROMETER: sh2_SensorId_e = 20;
pub const sh2_SensorId_e_SH2_ACCELEROMETER: sh2_SensorId_e = 1;
pub const sh2_SensorId_e_SH2_LINEAR_ACCELERATION: sh2_SensorId_e = 4;
pub const sh2_SensorId_e_SH2_GRAVITY: sh2_SensorId_e = 6;
pub const sh2_SensorId_e_SH2_RAW_GYROSCOPE: sh2_SensorId_e = 21;
pub const sh2_SensorId_e_SH2_GYROSCOPE_CALIBRATED: sh2_SensorId_e = 2;
pub const sh2_SensorId_e_SH2_GYROSCOPE_UNCALIBRATED: sh2_SensorId_e = 7;
pub const sh2_SensorId_e_SH2_RAW_MAGNETOMETER: sh2_SensorId_e = 22;
pub const sh2_SensorId_e_SH2_MAGNETIC_FIELD_CALIBRATED: sh2_SensorId_e = 3;
pub const sh2_SensorId_e_SH2_MAGNETIC_FIELD_UNCALIBRATED: sh2_SensorId_e = 15;
pub const sh2_SensorId_e_SH2_ROTATION_VECTOR: sh2_SensorId_e = 5;
pub const sh2_SensorId_e_SH2_GAME_ROTATION_VECTOR: sh2_SensorId_e = 8;
pub const sh2_SensorId_e_SH2_GEOMAGNETIC_ROTATION_VECTOR: sh2_SensorId_e = 9;
pub const sh2_SensorId_e_SH2_PRESSURE: sh2_SensorId_e = 10;
pub const sh2_SensorId_e_SH2_AMBIENT_LIGHT: sh2_SensorId_e = 11;
pub const sh2_SensorId_e_SH2_HUMIDITY: sh2_SensorId_e = 12;
pub const sh2_SensorId_e_SH2_PROXIMITY: sh2_SensorId_e = 13;
pub const sh2_SensorId_e_SH2_TEMPERATURE: sh2_SensorId_e = 14;
pub const sh2_SensorId_e_SH2_RESERVED: sh2_SensorId_e = 23;
pub const sh2_SensorId_e_SH2_TAP_DETECTOR: sh2_SensorId_e = 16;
pub const sh2_SensorId_e_SH2_STEP_DETECTOR: sh2_SensorId_e = 24;
pub const sh2_SensorId_e_SH2_STEP_COUNTER: sh2_SensorId_e = 17;
pub const sh2_SensorId_e_SH2_SIGNIFICANT_MOTION: sh2_SensorId_e = 18;
pub const sh2_SensorId_e_SH2_STABILITY_CLASSIFIER: sh2_SensorId_e = 19;
pub const sh2_SensorId_e_SH2_SHAKE_DETECTOR: sh2_SensorId_e = 25;
pub const sh2_SensorId_e_SH2_FLIP_DETECTOR: sh2_SensorId_e = 26;
pub const sh2_SensorId_e_SH2_PICKUP_DETECTOR: sh2_SensorId_e = 27;
pub const sh2_SensorId_e_SH2_STABILITY_DETECTOR: sh2_SensorId_e = 28;
pub const sh2_SensorId_e_SH2_PERSONAL_ACTIVITY_CLASSIFIER: sh2_SensorId_e = 30;
pub const sh2_SensorId_e_SH2_SLEEP_DETECTOR: sh2_SensorId_e = 31;
pub const sh2_SensorId_e_SH2_TILT_DETECTOR: sh2_SensorId_e = 32;
pub const sh2_SensorId_e_SH2_POCKET_DETECTOR: sh2_SensorId_e = 33;
pub const sh2_SensorId_e_SH2_CIRCLE_DETECTOR: sh2_SensorId_e = 34;
pub const sh2_SensorId_e_SH2_HEART_RATE_MONITOR: sh2_SensorId_e = 35;
pub const sh2_SensorId_e_SH2_ARVR_STABILIZED_RV: sh2_SensorId_e = 40;
pub const sh2_SensorId_e_SH2_ARVR_STABILIZED_GRV: sh2_SensorId_e = 41;
pub const sh2_SensorId_e_SH2_GYRO_INTEGRATED_RV: sh2_SensorId_e = 42;
pub const sh2_SensorId_e_SH2_IZRO_MOTION_REQUEST: sh2_SensorId_e = 43;
pub const sh2_SensorId_e_SH2_RAW_OPTICAL_FLOW: sh2_SensorId_e = 44;
pub const sh2_SensorId_e_SH2_DEAD_RECKONING_POSE: sh2_SensorId_e = 45;
pub const sh2_SensorId_e_SH2_WHEEL_ENCODER: sh2_SensorId_e = 46;
pub const sh2_SensorId_e_SH2_MAX_SENSOR_ID: sh2_SensorId_e = 46;
#[doc = " @brief List of sensor types supported by the hub\n\n See the SH-2 Reference Manual for more information on each type."]
pub type sh2_SensorId_e = ::core::ffi::c_int;
pub type sh2_SensorId_t = u8;
#[doc = " @brief Sensor Configuration settings\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorConfig {
    #[doc = "< @brief Enable reports on change"]
    pub changeSensitivityEnabled: bool,
    #[doc = "< @brief Change reports relative (vs absolute)"]
    pub changeSensitivityRelative: bool,
    #[doc = "< @brief Wake host on event"]
    pub wakeupEnabled: bool,
    #[doc = "< @brief Sensor remains on in sleep state"]
    pub alwaysOnEnabled: bool,
    #[doc = "< @brief Any output from this sensor should\nbe sent to host, but reportInterval_us and\nsensorSpecific do not influence sensor\noperation. Not supported by all sensors."]
    pub sniffEnabled: bool,
    #[doc = "< @brief Report-on-change threshold"]
    pub changeSensitivity: u16,
    #[doc = "< @brief [uS] Report interval"]
    pub reportInterval_us: u32,
    #[doc = "< @brief [uS] Batch interval"]
    pub batchInterval_us: u32,
    #[doc = "< @brief See SH-2 Reference Manual for details."]
    pub sensorSpecific: u32,
}
#[test]
fn bindgen_test_layout_sh2_SensorConfig() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SensorConfig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorConfig>(),
        20usize,
        concat!("Size of: ", stringify!(sh2_SensorConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorConfig))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).changeSensitivityEnabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(changeSensitivityEnabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).changeSensitivityRelative) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(changeSensitivityRelative)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wakeupEnabled) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(wakeupEnabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alwaysOnEnabled) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(alwaysOnEnabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sniffEnabled) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(sniffEnabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).changeSensitivity) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(changeSensitivity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reportInterval_us) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(reportInterval_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).batchInterval_us) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(batchInterval_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensorSpecific) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfig),
            "::",
            stringify!(sensorSpecific)
        )
    );
}
#[doc = " @brief Sensor Configuration settings\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_SensorConfig_t = sh2_SensorConfig;
#[doc = " @brief Sensor Metadata Record\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorMetadata {
    #[doc = "< @brief Motion Engine Version"]
    pub meVersion: u8,
    #[doc = "< @brief Motion Hub Version"]
    pub mhVersion: u8,
    #[doc = "< @brief SensorHub Version"]
    pub shVersion: u8,
    #[doc = "< @brief Same units as sensor reports"]
    pub range: u32,
    #[doc = "< @brief Same units as sensor reports"]
    pub resolution: u32,
    #[doc = "< @brief Metadata record format revision"]
    pub revision: u16,
    #[doc = "< @brief [mA] Fixed point 16Q10 format"]
    pub power_mA: u16,
    #[doc = "< @brief [uS]"]
    pub minPeriod_uS: u32,
    #[doc = "< @brief [uS]"]
    pub maxPeriod_uS: u32,
    #[doc = "< @brief (Unused)"]
    pub fifoReserved: u32,
    #[doc = "< @brief (Unused)"]
    pub fifoMax: u32,
    #[doc = "< @brief (Unused)"]
    pub batchBufferBytes: u32,
    #[doc = "< @brief q point for sensor values"]
    pub qPoint1: u16,
    #[doc = "< @brief q point for accuracy or bias fields"]
    pub qPoint2: u16,
    #[doc = "< @brief q point for sensor data change sensitivity"]
    pub qPoint3: u16,
    #[doc = "< @brief [bytes]"]
    pub vendorIdLen: u32,
    #[doc = "< @brief Vendor name and part number"]
    pub vendorId: [::core::ffi::c_char; 48usize],
    #[doc = "< @brief [bytes]"]
    pub sensorSpecificLen: u32,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub sensorSpecific: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_sh2_SensorMetadata() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SensorMetadata> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorMetadata>(),
        148usize,
        concat!("Size of: ", stringify!(sh2_SensorMetadata))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorMetadata>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorMetadata))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(meVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mhVersion) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(mhVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shVersion) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(shVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resolution) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).power_mA) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(power_mA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minPeriod_uS) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(minPeriod_uS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxPeriod_uS) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(maxPeriod_uS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifoReserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(fifoReserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifoMax) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(fifoMax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).batchBufferBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(batchBufferBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qPoint1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(qPoint1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qPoint2) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(qPoint2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qPoint3) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(qPoint3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendorIdLen) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(vendorIdLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendorId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensorSpecificLen) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(sensorSpecificLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensorSpecific) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorMetadata),
            "::",
            stringify!(sensorSpecific)
        )
    );
}
#[doc = " @brief Sensor Metadata Record\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_SensorMetadata_t = sh2_SensorMetadata;
#[doc = " @brief SensorHub Error Record\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ErrorRecord {
    #[doc = "< @brief Error severity, 0: most severe."]
    pub severity: u8,
    #[doc = "< @brief Sequence number (by severity)"]
    pub sequence: u8,
    #[doc = "< @brief 1-MotionEngine, 2-MotionHub, 3-SensorHub, 4-Chip"]
    pub source: u8,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub error: u8,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub module: u8,
    #[doc = "< @brief See SH-2 Reference Manual"]
    pub code: u8,
}
#[test]
fn bindgen_test_layout_sh2_ErrorRecord() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_ErrorRecord> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_ErrorRecord>(),
        6usize,
        concat!("Size of: ", stringify!(sh2_ErrorRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ErrorRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_ErrorRecord))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).severity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(severity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ErrorRecord),
            "::",
            stringify!(code)
        )
    );
}
#[doc = " @brief SensorHub Error Record\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_ErrorRecord_t = sh2_ErrorRecord;
#[doc = " @brief SensorHub Counter Record\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Counts {
    #[doc = "< @brief [events]"]
    pub offered: u32,
    #[doc = "< @brief [events]"]
    pub accepted: u32,
    #[doc = "< @brief [events]"]
    pub on: u32,
    #[doc = "< @brief [events]"]
    pub attempted: u32,
}
#[test]
fn bindgen_test_layout_sh2_Counts() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Counts> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Counts>(),
        16usize,
        concat!("Size of: ", stringify!(sh2_Counts))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Counts>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Counts))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offered) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(offered)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accepted) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(accepted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(on)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attempted) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Counts),
            "::",
            stringify!(attempted)
        )
    );
}
#[doc = " @brief SensorHub Counter Record\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Counts_t = sh2_Counts;
#[doc = "< @brief Use Rotation Vector"]
pub const sh2_TareBasis_SH2_TARE_BASIS_ROTATION_VECTOR: sh2_TareBasis = 0;
#[doc = "< @brief Use Game Rotation Vector"]
pub const sh2_TareBasis_SH2_TARE_BASIS_GAMING_ROTATION_VECTOR: sh2_TareBasis = 1;
#[doc = "< @brief Use Geomagnetic R.V."]
pub const sh2_TareBasis_SH2_TARE_BASIS_GEOMAGNETIC_ROTATION_VECTOR: sh2_TareBasis = 2;
#[doc = " @brief Values for specifying tare basis\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_TareBasis = ::core::ffi::c_int;
#[doc = " @brief Values for specifying tare basis\n\n See the SH-2 Reference Manual for more detail."]
pub use self::sh2_TareBasis as sh2_TareBasis_t;
#[doc = "< @brief sh2_tareNow() axes bit field"]
pub const sh2_TareAxis_SH2_TARE_X: sh2_TareAxis = 1;
#[doc = "< @brief sh2_tareNow() axes bit field"]
pub const sh2_TareAxis_SH2_TARE_Y: sh2_TareAxis = 2;
#[doc = "< @brief sh2_tareNow() axes bit field"]
pub const sh2_TareAxis_SH2_TARE_Z: sh2_TareAxis = 4;
#[doc = "< @brief Use X axis of source and frame to perform tare"]
pub const sh2_TareAxis_SH2_TARE_CONTROL_VECTOR_X: sh2_TareAxis = 8;
#[doc = "< @brief Use Y axis of source and frame to perform tare"]
pub const sh2_TareAxis_SH2_TARE_CONTROL_VECTOR_Y: sh2_TareAxis = 0;
#[doc = "< @brief Use Z axis of source and frame to perform tare"]
pub const sh2_TareAxis_SH2_TARE_CONTROL_VECTOR_Z: sh2_TareAxis = 16;
#[doc = "< @brief Tare \"typical\" toration for source/axis combination"]
pub const sh2_TareAxis_SH2_TARE_CONTROL_SEQUENCE_DEFAULT: sh2_TareAxis = 0;
#[doc = "< @brief Apply to pre-rotation (tare world to device)"]
pub const sh2_TareAxis_SH2_TARE_CONTROL_SEQUENCE_PRE: sh2_TareAxis = 32;
#[doc = "< @brief Apply to post-rotation (tare device to world)"]
pub const sh2_TareAxis_SH2_TARE_CONTROL_SEQUENCE_POST: sh2_TareAxis = 64;
#[doc = " @brief Bit Fields for specifying tare axes.\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_TareAxis = ::core::ffi::c_int;
#[doc = " @brief Bit Fields for specifying tare axes.\n\n See the SH-2 Reference Manual for more detail."]
pub use self::sh2_TareAxis as sh2_TareAxis_t;
#[doc = " @brief Quaternion (double precision floating point representation.)\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Quaternion {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_sh2_Quaternion() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Quaternion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Quaternion>(),
        32usize,
        concat!("Size of: ", stringify!(sh2_Quaternion))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Quaternion>(),
        8usize,
        concat!("Alignment of ", stringify!(sh2_Quaternion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Quaternion),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " @brief Quaternion (double precision floating point representation.)\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Quaternion_t = sh2_Quaternion;
pub const sh2_OscType_t_SH2_OSC_INTERNAL: sh2_OscType_t = 0;
pub const sh2_OscType_t_SH2_OSC_EXT_CRYSTAL: sh2_OscType_t = 1;
pub const sh2_OscType_t_SH2_OSC_EXT_CLOCK: sh2_OscType_t = 2;
#[doc = " @brief Oscillator type: Internal or External\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_OscType_t = ::core::ffi::c_int;
pub const sh2_CalStatus_t_SH2_CAL_SUCCESS: sh2_CalStatus_t = 0;
pub const sh2_CalStatus_t_SH2_CAL_NO_ZRO: sh2_CalStatus_t = 1;
pub const sh2_CalStatus_t_SH2_CAL_NO_STATIONARY_DETECTION: sh2_CalStatus_t = 2;
pub const sh2_CalStatus_t_SH2_CAL_ROTATION_OUTSIDE_SPEC: sh2_CalStatus_t = 3;
pub const sh2_CalStatus_t_SH2_CAL_ZRO_OUTSIDE_SPEC: sh2_CalStatus_t = 4;
pub const sh2_CalStatus_t_SH2_CAL_ZGO_OUTSIDE_SPEC: sh2_CalStatus_t = 5;
pub const sh2_CalStatus_t_SH2_CAL_GYRO_GAIN_OUTSIDE_SPEC: sh2_CalStatus_t = 6;
pub const sh2_CalStatus_t_SH2_CAL_GYRO_PERIOD_OUTSIDE_SPEC: sh2_CalStatus_t = 7;
pub const sh2_CalStatus_t_SH2_CAL_GYRO_DROPS_OUTSIDE_SPEC: sh2_CalStatus_t = 8;
#[doc = " @brief Calibration result\n\n See the SH-2 Reference Manual, Finish Calibration Response."]
pub type sh2_CalStatus_t = ::core::ffi::c_int;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_UNKNOWN: sh2_IZroMotionIntent_t = 0;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_STATIONARY_NO_VIBRATION: sh2_IZroMotionIntent_t = 1;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_STATIONARY_WITH_VIBRATION: sh2_IZroMotionIntent_t = 2;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_IN_MOTION: sh2_IZroMotionIntent_t = 3;
pub const sh2_IZroMotionIntent_t_SH2_IZRO_MI_ACCELERATING: sh2_IZroMotionIntent_t = 4;
#[doc = " @brief Interactive ZRO Motion Intent\n\n See the SH-2 Reference Manual, 6.4.13"]
pub type sh2_IZroMotionIntent_t = ::core::ffi::c_int;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_NO_REQUEST: sh2_IZroMotionRequest_t = 0;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_STAY_STATIONARY: sh2_IZroMotionRequest_t = 1;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_STATIONARY_NON_URGENT: sh2_IZroMotionRequest_t = 2;
pub const sh2_IZroMotionRequest_t_SH2_IZRO_MR_STATIONARY_URGENT: sh2_IZroMotionRequest_t = 3;
#[doc = " @brief Interactive ZRO Motion Intent\n\n See the SH-2 Reference Manual, 6.4.13"]
pub type sh2_IZroMotionRequest_t = ::core::ffi::c_int;
pub const sh2_AsyncEventId_e_SH2_RESET: sh2_AsyncEventId_e = 0;
pub const sh2_AsyncEventId_e_SH2_SHTP_EVENT: sh2_AsyncEventId_e = 1;
pub const sh2_AsyncEventId_e_SH2_GET_FEATURE_RESP: sh2_AsyncEventId_e = 2;
#[doc = " @brief Asynchronous Event\n\n Represents reset events and other non-sensor events received from SH-2 sensor hub."]
pub type sh2_AsyncEventId_e = ::core::ffi::c_int;
#[doc = " @brief Asynchronous Event\n\n Represents reset events and other non-sensor events received from SH-2 sensor hub."]
pub use self::sh2_AsyncEventId_e as sh2_AsyncEventId_t;
pub const sh2_ShtpEvent_e_SH2_SHTP_TX_DISCARD: sh2_ShtpEvent_e = 0;
pub const sh2_ShtpEvent_e_SH2_SHTP_SHORT_FRAGMENT: sh2_ShtpEvent_e = 1;
pub const sh2_ShtpEvent_e_SH2_SHTP_TOO_LARGE_PAYLOADS: sh2_ShtpEvent_e = 2;
pub const sh2_ShtpEvent_e_SH2_SHTP_BAD_RX_CHAN: sh2_ShtpEvent_e = 3;
pub const sh2_ShtpEvent_e_SH2_SHTP_BAD_TX_CHAN: sh2_ShtpEvent_e = 4;
pub const sh2_ShtpEvent_e_SH2_SHTP_BAD_FRAGMENT: sh2_ShtpEvent_e = 5;
pub const sh2_ShtpEvent_e_SH2_SHTP_BAD_SN: sh2_ShtpEvent_e = 6;
pub const sh2_ShtpEvent_e_SH2_SHTP_INTERRUPTED_PAYLOAD: sh2_ShtpEvent_e = 7;
pub type sh2_ShtpEvent_e = ::core::ffi::c_int;
pub type sh2_ShtpEvent_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SensorConfigResp_e {
    pub sensorId: sh2_SensorId_t,
    pub sensorConfig: sh2_SensorConfig_t,
}
#[test]
fn bindgen_test_layout_sh2_SensorConfigResp_e() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SensorConfigResp_e> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorConfigResp_e>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_SensorConfigResp_e))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorConfigResp_e>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorConfigResp_e))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensorId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfigResp_e),
            "::",
            stringify!(sensorId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensorConfig) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorConfigResp_e),
            "::",
            stringify!(sensorConfig)
        )
    );
}
pub type sh2_SensorConfigResp_t = sh2_SensorConfigResp_e;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sh2_AsyncEvent {
    pub eventId: u32,
    pub __bindgen_anon_1: sh2_AsyncEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sh2_AsyncEvent__bindgen_ty_1 {
    pub shtpEvent: sh2_ShtpEvent_t,
    pub sh2SensorConfigResp: sh2_SensorConfigResp_t,
}
#[test]
fn bindgen_test_layout_sh2_AsyncEvent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_AsyncEvent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_AsyncEvent__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_AsyncEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_AsyncEvent__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_AsyncEvent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shtpEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AsyncEvent__bindgen_ty_1),
            "::",
            stringify!(shtpEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sh2SensorConfigResp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AsyncEvent__bindgen_ty_1),
            "::",
            stringify!(sh2SensorConfigResp)
        )
    );
}
#[test]
fn bindgen_test_layout_sh2_AsyncEvent() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_AsyncEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_AsyncEvent>(),
        28usize,
        concat!("Size of: ", stringify!(sh2_AsyncEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_AsyncEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_AsyncEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AsyncEvent),
            "::",
            stringify!(eventId)
        )
    );
}
pub type sh2_AsyncEvent_t = sh2_AsyncEvent;
pub type sh2_EventCallback_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut ::core::ffi::c_void, pEvent: *mut sh2_AsyncEvent_t),
>;
extern "C" {
    #[doc = " @brief Open a session with a sensor hub.\n\n This function should be called before others in this API.\n An instance of an SH2 HAL should be passed in.\n This call will result in the open() function of the HAL being called.\n\n As part of the initialization process, a callback function is registered that will\n be invoked when the device generates certain events.  (See sh2_AsyncEventId)\n\n @param pHal Pointer to an SH2 HAL instance, provided by the target system.\n @param  eventCallback Will be called when events, such as reset complete, occur.\n @param  eventCookie Will be passed to eventCallback.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_open(
        pHal: *mut sh2_Hal_t,
        eventCallback: sh2_EventCallback_t,
        eventCookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Close a session with a sensor hub.\n\n This should be called at the end of a sensor hub session.\n The underlying SHTP and HAL instances will be closed.\n"]
    pub fn sh2_close();
}
extern "C" {
    #[doc = " @brief Service the SH2 device, reading any data that is available and dispatching callbacks.\n\n This function should be called periodically by the host system to service an open sensor hub.\n"]
    pub fn sh2_service();
}
extern "C" {
    #[doc = " @brief Register a function to receive sensor events.\n\n @param  callback A function that will be called each time a sensor event is received.\n @param  cookie  A value that will be passed to the sensor callback function.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setSensorCallback(
        callback: sh2_SensorCallback_t,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Reset the sensor hub device by sending RESET (1) command on \"device\" channel.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_devReset() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Turn sensor hub on by sending ON (2) command on \"device\" channel.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_devOn() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Put sensor hub in sleep state by sending SLEEP (3) command on \"device\" channel.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_devSleep() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get Product ID information from Sensorhub.\n\n @param  prodIds Pointer to structure that will receive results.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getProdIds(prodIds: *mut sh2_ProductIds_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get sensor configuration.\n\n @param  sensorId Which sensor to query.\n @param  config SensorConfig structure to store results.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getSensorConfig(
        sensorId: sh2_SensorId_t,
        config: *mut sh2_SensorConfig_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set sensor configuration. (e.g enable a sensor at a particular rate.)\n\n @param  sensorId Which sensor to configure.\n @param  pConfig Pointer to structure holding sensor configuration.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setSensorConfig(
        sensorId: sh2_SensorId_t,
        pConfig: *const sh2_SensorConfig_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get metadata related to a sensor.\n\n @param  sensorId Which sensor to query.\n @param  pData Pointer to structure to receive the results.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getMetadata(
        sensorId: sh2_SensorId_t,
        pData: *mut sh2_SensorMetadata_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get an FRS record.\n\n @param  recordId Which FRS Record to retrieve.\n @param  pData pointer to buffer to receive the results\n @param[in] words Size of pData buffer, in 32-bit words.\n @param[out] words Number of 32-bit words retrieved.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getFrs(recordId: u16, pData: *mut u32, words: *mut u16) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set an FRS record\n\n @param  recordId Which FRS Record to set.\n @param  pData pointer to buffer containing the new data.\n @param  words number of 32-bit words to write.  (0 to delete record.)\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setFrs(recordId: u16, pData: *mut u32, words: u16) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get error counts.\n\n @param  severity Only errors of this severity or greater are returned.\n @param  pErrors Buffer to receive error codes.\n @param  numErrors size of pErrors array\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getErrors(
        severity: u8,
        pErrors: *mut sh2_ErrorRecord_t,
        numErrors: *mut u16,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Read counters related to a sensor.\n\n @param  sensorId Which sensor to operate on.\n @param  pCounts Pointer to Counts structure that will receive data.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getCounts(
        sensorId: sh2_SensorId_t,
        pCounts: *mut sh2_Counts_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Clear counters related to a sensor.\n\n @param  sensorId which sensor to operate on.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_clearCounts(sensorId: sh2_SensorId_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Perform a tare operation on one or more axes.\n\n @param  axes Bit mask specifying which axes should be tared.\n @param  basis Which rotation vector to use as the basis for Tare adjustment.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setTareNow(axes: u8, basis: sh2_TareBasis_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Clears the previously applied tare operation.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_clearTare() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Persist the results of last tare operation to flash.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_persistTare() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set the current run-time sensor reorientation. (Set to zero to clear tare.)\n\n @param  orientation Quaternion rotation vector to apply as new tare.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setReorientation(orientation: *mut sh2_Quaternion_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Command the sensorhub to reset.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_reinitialize() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Save Dynamic Calibration Data to flash.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_saveDcdNow() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get Oscillator type.\n\n @param  pOscType pointer to data structure to receive results.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getOscType(pOscType: *mut sh2_OscType_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Enable/Disable dynamic calibration for certain sensors\n\n @param  sensors Bit mask to configure which sensors are affected.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setCalConfig(sensors: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get dynamic calibration configuration settings.\n\n @param  pSensors pointer to Bit mask, set on return.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_getCalConfig(pSensors: *mut u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Configure automatic saving of dynamic calibration data.\n\n @param  enabled Enable or Disable DCD auto-save.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setDcdAutoSave(enabled: bool) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Immediately issue all buffered sensor reports from a given sensor.\n\n @param  sensorId Which sensor reports to flush.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_flush(sensorId: sh2_SensorId_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Command clear DCD in RAM, then reset sensor hub.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_clearDcdAndReset() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Start simple self-calibration procedure.\n\n @parameter interval_us sensor report interval, uS.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_startCal(interval_us: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Finish simple self-calibration procedure.\n\n @parameter status contains calibration status code on return.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_finishCal(status: *mut sh2_CalStatus_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief send Interactive ZRO Request.\n\n @parameter intent Inform the sensor hub what sort of motion should be in progress.\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_setIZro(intent: sh2_IZroMotionIntent_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Report wheel position/velocity to sensor hub.\n @parameter wheelIndex platform-dependent: 0= left, 1= right for\n   typical differential drive robot\n @parameter timestamp microsecond timestamp (hub scale) of measurement\n @parameter wheelData raw wheel position or velocity\n @parameter dataType 0 if data is position, 1 if data is velocity\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_reportWheelEncoder(
        wheelIndex: u8,
        timestamp: u32,
        wheelData: i16,
        dataType: u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Save Dead Reckoning Calibration Data to flash.\n\n @return SH2_OK (0), on success.  Negative value from sh2_err.h on error."]
    pub fn sh2_saveDeadReckoningCalNow() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn readu8(buffer: *const u8) -> u8;
}
extern "C" {
    pub fn writeu8(buffer: *mut u8, value: u8);
}
extern "C" {
    pub fn readu16(buffer: *const u8) -> u16;
}
extern "C" {
    pub fn writeu16(buffer: *mut u8, value: u16);
}
extern "C" {
    pub fn readu32(buffer: *const u8) -> u32;
}
extern "C" {
    pub fn writeu32(buffer: *mut u8, value: u32);
}
extern "C" {
    pub fn read8(buffer: *const u8) -> i8;
}
extern "C" {
    pub fn write8(buffer: *mut u8, value: i8);
}
extern "C" {
    pub fn read16(buffer: *const u8) -> i16;
}
extern "C" {
    pub fn write16(buffer: *mut u8, value: i16);
}
extern "C" {
    pub fn read32(buffer: *const u8) -> i32;
}
extern "C" {
    pub fn write32(buffer: *mut u8, value: i32);
}
#[doc = " @brief Raw Accelerometer\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RawAccelerometer {
    #[doc = "< @brief [ADC counts]"]
    pub x: i16,
    #[doc = "< @brief [ADC counts]"]
    pub y: i16,
    #[doc = "< @brief [ADC counts]"]
    pub z: i16,
    #[doc = "< @brief [uS]"]
    pub timestamp: u32,
}
#[test]
fn bindgen_test_layout_sh2_RawAccelerometer() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_RawAccelerometer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_RawAccelerometer>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_RawAccelerometer))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RawAccelerometer>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RawAccelerometer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawAccelerometer),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = " @brief Raw Accelerometer\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_RawAccelerometer_t = sh2_RawAccelerometer;
#[doc = " @brief Accelerometer\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Accelerometer {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sh2_Accelerometer() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Accelerometer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Accelerometer>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_Accelerometer))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Accelerometer>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Accelerometer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Accelerometer),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Accelerometer),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Accelerometer),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " @brief Accelerometer\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Accelerometer_t = sh2_Accelerometer;
#[doc = " @brief Raw gyroscope\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RawGyroscope {
    #[doc = "< @brief [ADC Counts]"]
    pub x: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub y: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub z: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub temperature: i16,
    #[doc = "< @brief [uS]"]
    pub timestamp: u32,
}
#[test]
fn bindgen_test_layout_sh2_RawGyroscope() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_RawGyroscope> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_RawGyroscope>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_RawGyroscope))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RawGyroscope>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RawGyroscope))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawGyroscope),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = " @brief Raw gyroscope\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_RawGyroscope_t = sh2_RawGyroscope;
#[doc = " @brief Gyroscope\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Gyroscope {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sh2_Gyroscope() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Gyroscope> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Gyroscope>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_Gyroscope))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Gyroscope>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Gyroscope))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Gyroscope),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Gyroscope),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Gyroscope),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " @brief Gyroscope\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Gyroscope_t = sh2_Gyroscope;
#[doc = " @brief Uncalibrated gyroscope\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_GyroscopeUncalibrated {
    #[doc = "< @brief [rad/s]"]
    pub x: f32,
    #[doc = "< @brief [rad/s]"]
    pub y: f32,
    #[doc = "< @brief [rad/s]"]
    pub z: f32,
    #[doc = "< @brief [rad/s]"]
    pub biasX: f32,
    #[doc = "< @brief [rad/s]"]
    pub biasY: f32,
    #[doc = "< @brief [rad/s]"]
    pub biasZ: f32,
}
#[test]
fn bindgen_test_layout_sh2_GyroscopeUncalibrated() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_GyroscopeUncalibrated> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_GyroscopeUncalibrated>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_GyroscopeUncalibrated))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_GyroscopeUncalibrated>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_GyroscopeUncalibrated))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).biasX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(biasX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).biasY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(biasY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).biasZ) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroscopeUncalibrated),
            "::",
            stringify!(biasZ)
        )
    );
}
#[doc = " @brief Uncalibrated gyroscope\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_GyroscopeUncalibrated_t = sh2_GyroscopeUncalibrated;
#[doc = " @brief Raw Magnetometer\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RawMagnetometer {
    #[doc = "< @brief [ADC Counts]"]
    pub x: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub y: i16,
    #[doc = "< @brief [ADC Counts]"]
    pub z: i16,
    #[doc = "< @brief [uS]"]
    pub timestamp: u32,
}
#[test]
fn bindgen_test_layout_sh2_RawMagnetometer() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_RawMagnetometer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_RawMagnetometer>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_RawMagnetometer))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RawMagnetometer>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RawMagnetometer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawMagnetometer),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = " @brief Raw Magnetometer\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_RawMagnetometer_t = sh2_RawMagnetometer;
#[doc = " @brief Magnetic field\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_MagneticField {
    #[doc = "< @brief [uTesla]"]
    pub x: f32,
    #[doc = "< @brief [uTesla]"]
    pub y: f32,
    #[doc = "< @brief [uTesla]"]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_sh2_MagneticField() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_MagneticField> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_MagneticField>(),
        12usize,
        concat!("Size of: ", stringify!(sh2_MagneticField))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_MagneticField>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_MagneticField))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticField),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticField),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticField),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " @brief Magnetic field\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_MagneticField_t = sh2_MagneticField;
#[doc = " @brief Uncalibrated magnetic field\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_MagneticFieldUncalibrated {
    #[doc = "< @brief [uTesla]"]
    pub x: f32,
    #[doc = "< @brief [uTesla]"]
    pub y: f32,
    #[doc = "< @brief [uTesla]"]
    pub z: f32,
    #[doc = "< @brief [uTesla]"]
    pub biasX: f32,
    #[doc = "< @brief [uTesla]"]
    pub biasY: f32,
    #[doc = "< @brief [uTesla]"]
    pub biasZ: f32,
}
#[test]
fn bindgen_test_layout_sh2_MagneticFieldUncalibrated() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_MagneticFieldUncalibrated> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_MagneticFieldUncalibrated>(),
        24usize,
        concat!("Size of: ", stringify!(sh2_MagneticFieldUncalibrated))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_MagneticFieldUncalibrated>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_MagneticFieldUncalibrated))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).biasX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(biasX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).biasY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(biasY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).biasZ) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_MagneticFieldUncalibrated),
            "::",
            stringify!(biasZ)
        )
    );
}
#[doc = " @brief Uncalibrated magnetic field\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_MagneticFieldUncalibrated_t = sh2_MagneticFieldUncalibrated;
#[doc = " @brief Rotation Vector with Accuracy\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RotationVectorWAcc {
    #[doc = "< @brief Quaternion component i"]
    pub i: f32,
    #[doc = "< @brief Quaternion component j"]
    pub j: f32,
    #[doc = "< @brief Quaternion component k"]
    pub k: f32,
    #[doc = "< @brief Quaternion component, real"]
    pub real: f32,
    #[doc = "< @brief Accuracy estimate [radians]"]
    pub accuracy: f32,
}
#[test]
fn bindgen_test_layout_sh2_RotationVectorWAcc() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_RotationVectorWAcc> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_RotationVectorWAcc>(),
        20usize,
        concat!("Size of: ", stringify!(sh2_RotationVectorWAcc))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RotationVectorWAcc>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RotationVectorWAcc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accuracy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVectorWAcc),
            "::",
            stringify!(accuracy)
        )
    );
}
#[doc = " @brief Rotation Vector with Accuracy\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_RotationVectorWAcc_t = sh2_RotationVectorWAcc;
#[doc = " @brief Rotation Vector\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RotationVector {
    #[doc = "< @brief Quaternion component i"]
    pub i: f32,
    #[doc = "< @brief Quaternion component j"]
    pub j: f32,
    #[doc = "< @brief Quaternion component k"]
    pub k: f32,
    #[doc = "< @brief Quaternion component real"]
    pub real: f32,
}
#[test]
fn bindgen_test_layout_sh2_RotationVector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_RotationVector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_RotationVector>(),
        16usize,
        concat!("Size of: ", stringify!(sh2_RotationVector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RotationVector>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RotationVector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RotationVector),
            "::",
            stringify!(real)
        )
    );
}
#[doc = " @brief Rotation Vector\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_RotationVector_t = sh2_RotationVector;
#[doc = " @brief Atmospheric Pressure\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Pressure {
    #[doc = "< @brief Atmospheric Pressure.  [hectopascals]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Pressure() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Pressure> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Pressure>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Pressure))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Pressure>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Pressure))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Pressure),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Atmospheric Pressure\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Pressure_t = sh2_Pressure;
#[doc = " @brief Ambient Light\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_AmbientLight {
    #[doc = "< @brief Ambient Light.  [lux]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_AmbientLight() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_AmbientLight> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_AmbientLight>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_AmbientLight))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_AmbientLight>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_AmbientLight))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_AmbientLight),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Ambient Light\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_AmbientLight_t = sh2_AmbientLight;
#[doc = " @brief Humidity\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Humidity {
    #[doc = "< @brief Relative Humidity.  [percent]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Humidity() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Humidity> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Humidity>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Humidity))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Humidity>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Humidity))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Humidity),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Humidity\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Humidity_t = sh2_Humidity;
#[doc = " @brief Proximity\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Proximity {
    #[doc = "< @brief Proximity.  [cm]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Proximity() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Proximity> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Proximity>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Proximity))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Proximity>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Proximity))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Proximity),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Proximity\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Proximity_t = sh2_Proximity;
#[doc = " @brief Temperature\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Temperature {
    #[doc = "< @brief Temperature.  [C]"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sh2_Temperature() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Temperature> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Temperature>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Temperature))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Temperature>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Temperature))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Temperature),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Temperature\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Temperature_t = sh2_Temperature;
#[doc = " @brief Reserved\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_Reserved {
    #[doc = "< @brief Reserved"]
    pub tbd: f32,
}
#[test]
fn bindgen_test_layout_sh2_Reserved() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_Reserved> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_Reserved>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_Reserved))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_Reserved>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_Reserved))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tbd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_Reserved),
            "::",
            stringify!(tbd)
        )
    );
}
#[doc = " @brief Reserved\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_Reserved_t = sh2_Reserved;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_TapDetector {
    #[doc = "< @brief TapDetector."]
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_sh2_TapDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_TapDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_TapDetector>(),
        1usize,
        concat!("Size of: ", stringify!(sh2_TapDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_TapDetector>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_TapDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_TapDetector),
            "::",
            stringify!(flags)
        )
    );
}
pub type sh2_TapDetector_t = sh2_TapDetector;
#[doc = " @brief StepDetector\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StepDetector {
    #[doc = "< @brief Step detect latency [uS]."]
    pub latency: u32,
}
#[test]
fn bindgen_test_layout_sh2_StepDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_StepDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_StepDetector>(),
        4usize,
        concat!("Size of: ", stringify!(sh2_StepDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StepDetector>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_StepDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StepDetector),
            "::",
            stringify!(latency)
        )
    );
}
#[doc = " @brief StepDetector\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_StepDetector_t = sh2_StepDetector;
#[doc = " @brief StepCounter\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StepCounter {
    #[doc = "< @brief Step counter latency [uS]."]
    pub latency: u32,
    #[doc = "< @brief Steps counted."]
    pub steps: u16,
}
#[test]
fn bindgen_test_layout_sh2_StepCounter() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_StepCounter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_StepCounter>(),
        8usize,
        concat!("Size of: ", stringify!(sh2_StepCounter))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StepCounter>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_StepCounter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StepCounter),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).steps) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StepCounter),
            "::",
            stringify!(steps)
        )
    );
}
#[doc = " @brief StepCounter\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_StepCounter_t = sh2_StepCounter;
#[doc = " @brief SigMotion\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SigMotion {
    pub motion: u16,
}
#[test]
fn bindgen_test_layout_sh2_SigMotion() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SigMotion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SigMotion>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_SigMotion))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SigMotion>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_SigMotion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).motion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SigMotion),
            "::",
            stringify!(motion)
        )
    );
}
#[doc = " @brief SigMotion\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_SigMotion_t = sh2_SigMotion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StabilityClassifier {
    pub classification: u8,
}
#[test]
fn bindgen_test_layout_sh2_StabilityClassifier() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_StabilityClassifier> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_StabilityClassifier>(),
        1usize,
        concat!("Size of: ", stringify!(sh2_StabilityClassifier))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StabilityClassifier>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_StabilityClassifier))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).classification) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StabilityClassifier),
            "::",
            stringify!(classification)
        )
    );
}
pub type sh2_StabilityClassifier_t = sh2_StabilityClassifier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_ShakeDetector {
    pub shake: u16,
}
#[test]
fn bindgen_test_layout_sh2_ShakeDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_ShakeDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_ShakeDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_ShakeDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_ShakeDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_ShakeDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shake) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_ShakeDetector),
            "::",
            stringify!(shake)
        )
    );
}
pub type sh2_ShakeDetector_t = sh2_ShakeDetector;
#[doc = " @brief flipDetector\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_FlipDetector {
    pub flip: u16,
}
#[test]
fn bindgen_test_layout_sh2_FlipDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_FlipDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_FlipDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_FlipDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_FlipDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_FlipDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_FlipDetector),
            "::",
            stringify!(flip)
        )
    );
}
#[doc = " @brief flipDetector\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_FlipDetector_t = sh2_FlipDetector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_PickupDetector {
    #[doc = "< flag field with bits defined above."]
    pub pickup: u16,
}
#[test]
fn bindgen_test_layout_sh2_PickupDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_PickupDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_PickupDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_PickupDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_PickupDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_PickupDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pickup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PickupDetector),
            "::",
            stringify!(pickup)
        )
    );
}
pub type sh2_PickupDetector_t = sh2_PickupDetector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_StabilityDetector {
    #[doc = "< flag field with bits defined above."]
    pub stability: u16,
}
#[test]
fn bindgen_test_layout_sh2_StabilityDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_StabilityDetector> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_StabilityDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_StabilityDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_StabilityDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_StabilityDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stability) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_StabilityDetector),
            "::",
            stringify!(stability)
        )
    );
}
pub type sh2_StabilityDetector_t = sh2_StabilityDetector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_PersonalActivityClassifier {
    pub page: u8,
    pub lastPage: bool,
    pub mostLikelyState: u8,
    pub confidence: [u8; 10usize],
}
#[test]
fn bindgen_test_layout_sh2_PersonalActivityClassifier() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_PersonalActivityClassifier> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_PersonalActivityClassifier>(),
        13usize,
        concat!("Size of: ", stringify!(sh2_PersonalActivityClassifier))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_PersonalActivityClassifier>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_PersonalActivityClassifier))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).page) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lastPage) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(lastPage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mostLikelyState) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(mostLikelyState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PersonalActivityClassifier),
            "::",
            stringify!(confidence)
        )
    );
}
pub type sh2_PersonalActivityClassifier_t = sh2_PersonalActivityClassifier;
#[doc = " @brief sleepDetector\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_SleepDetector {
    pub sleepState: u8,
}
#[test]
fn bindgen_test_layout_sh2_SleepDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SleepDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SleepDetector>(),
        1usize,
        concat!("Size of: ", stringify!(sh2_SleepDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SleepDetector>(),
        1usize,
        concat!("Alignment of ", stringify!(sh2_SleepDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sleepState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SleepDetector),
            "::",
            stringify!(sleepState)
        )
    );
}
#[doc = " @brief sleepDetector\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_SleepDetector_t = sh2_SleepDetector;
#[doc = " @brief tiltDetector\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_TiltDetector {
    pub tilt: u16,
}
#[test]
fn bindgen_test_layout_sh2_TiltDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_TiltDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_TiltDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_TiltDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_TiltDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_TiltDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tilt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_TiltDetector),
            "::",
            stringify!(tilt)
        )
    );
}
#[doc = " @brief tiltDetector\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_TiltDetector_t = sh2_TiltDetector;
#[doc = " @brief pocketDetector\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_PocketDetector {
    pub pocket: u16,
}
#[test]
fn bindgen_test_layout_sh2_PocketDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_PocketDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_PocketDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_PocketDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_PocketDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_PocketDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pocket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_PocketDetector),
            "::",
            stringify!(pocket)
        )
    );
}
#[doc = " @brief pocketDetector\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_PocketDetector_t = sh2_PocketDetector;
#[doc = " @brief circleDetector\n\n See the SH-2 Reference Manual for more detail."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_CircleDetector {
    pub circle: u16,
}
#[test]
fn bindgen_test_layout_sh2_CircleDetector() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_CircleDetector> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_CircleDetector>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_CircleDetector))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_CircleDetector>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_CircleDetector))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).circle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_CircleDetector),
            "::",
            stringify!(circle)
        )
    );
}
#[doc = " @brief circleDetector\n\n See the SH-2 Reference Manual for more detail."]
pub type sh2_CircleDetector_t = sh2_CircleDetector;
#[doc = " @brief heartRateMonitor\n\n See SH-2 Reference Manual for details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_HeartRateMonitor {
    #[doc = "< heart rate in beats per minute."]
    pub heartRate: u16,
}
#[test]
fn bindgen_test_layout_sh2_HeartRateMonitor() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_HeartRateMonitor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_HeartRateMonitor>(),
        2usize,
        concat!("Size of: ", stringify!(sh2_HeartRateMonitor))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_HeartRateMonitor>(),
        2usize,
        concat!("Alignment of ", stringify!(sh2_HeartRateMonitor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heartRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_HeartRateMonitor),
            "::",
            stringify!(heartRate)
        )
    );
}
#[doc = " @brief heartRateMonitor\n\n See SH-2 Reference Manual for details."]
pub type sh2_HeartRateMonitor_t = sh2_HeartRateMonitor;
#[doc = " @brief Gyro Integrated Rotation Vector\n\n See SH-2 Reference Manual for details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_GyroIntegratedRV {
    #[doc = "< @brief Quaternion component i"]
    pub i: f32,
    #[doc = "< @brief Quaternion component j"]
    pub j: f32,
    #[doc = "< @brief Quaternion component k"]
    pub k: f32,
    #[doc = "< @brief Quaternion component real"]
    pub real: f32,
    #[doc = "< @brief Angular velocity about x [rad/s]"]
    pub angVelX: f32,
    #[doc = "< @brief Angular velocity about y [rad/s]"]
    pub angVelY: f32,
    #[doc = "< @brief Angular velocity about z [rad/s]"]
    pub angVelZ: f32,
}
#[test]
fn bindgen_test_layout_sh2_GyroIntegratedRV() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_GyroIntegratedRV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_GyroIntegratedRV>(),
        28usize,
        concat!("Size of: ", stringify!(sh2_GyroIntegratedRV))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_GyroIntegratedRV>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_GyroIntegratedRV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angVelX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(angVelX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angVelY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(angVelY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angVelZ) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_GyroIntegratedRV),
            "::",
            stringify!(angVelZ)
        )
    );
}
#[doc = " @brief Gyro Integrated Rotation Vector\n\n See SH-2 Reference Manual for details."]
pub type sh2_GyroIntegratedRV_t = sh2_GyroIntegratedRV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_IZroRequest {
    pub intent: sh2_IZroMotionIntent_t,
    pub request: sh2_IZroMotionRequest_t,
}
#[test]
fn bindgen_test_layout_sh2_IZroRequest() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_IZroRequest> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_IZroRequest>(),
        8usize,
        concat!("Size of: ", stringify!(sh2_IZroRequest))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_IZroRequest>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_IZroRequest))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_IZroRequest),
            "::",
            stringify!(intent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_IZroRequest),
            "::",
            stringify!(request)
        )
    );
}
pub type sh2_IZroRequest_t = sh2_IZroRequest;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_RawOptFlow {
    pub timestamp: u32,
    pub dt: i16,
    pub dx: i16,
    pub dy: i16,
    pub iq: i16,
    pub resX: u8,
    pub resY: u8,
    pub shutter: u8,
    pub frameMax: u8,
    pub frameAvg: u8,
    pub frameMin: u8,
    pub laserOn: u8,
}
#[test]
fn bindgen_test_layout_sh2_RawOptFlow() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_RawOptFlow> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_RawOptFlow>(),
        20usize,
        concat!("Size of: ", stringify!(sh2_RawOptFlow))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_RawOptFlow>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_RawOptFlow))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(dt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dx) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iq) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(iq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(resX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resY) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(resY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shutter) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(shutter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameMax) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(frameMax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameAvg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(frameAvg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameMin) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(frameMin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).laserOn) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_RawOptFlow),
            "::",
            stringify!(laserOn)
        )
    );
}
pub type sh2_RawOptFlow_t = sh2_RawOptFlow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_DeadReckoningPose {
    pub timestamp: u32,
    pub linPosX: f32,
    pub linPosY: f32,
    pub linPosZ: f32,
    pub i: f32,
    pub j: f32,
    pub k: f32,
    pub real: f32,
    pub linVelX: f32,
    pub linVelY: f32,
    pub linVelZ: f32,
    pub angVelX: f32,
    pub angVelY: f32,
    pub angVelZ: f32,
}
#[test]
fn bindgen_test_layout_sh2_DeadReckoningPose() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_DeadReckoningPose> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_DeadReckoningPose>(),
        56usize,
        concat!("Size of: ", stringify!(sh2_DeadReckoningPose))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_DeadReckoningPose>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_DeadReckoningPose))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linPosX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(linPosX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linPosY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(linPosY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linPosZ) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(linPosZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).real) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linVelX) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(linVelX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linVelY) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(linVelY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linVelZ) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(linVelZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angVelX) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(angVelX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angVelY) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(angVelY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angVelZ) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_DeadReckoningPose),
            "::",
            stringify!(angVelZ)
        )
    );
}
pub type sh2_DeadReckoningPose_t = sh2_DeadReckoningPose;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sh2_WheelEncoder {
    pub timestamp: u32,
    pub wheelIndex: u8,
    pub dataType: u8,
    pub data: u16,
}
#[test]
fn bindgen_test_layout_sh2_WheelEncoder() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_WheelEncoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_WheelEncoder>(),
        8usize,
        concat!("Size of: ", stringify!(sh2_WheelEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_WheelEncoder>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_WheelEncoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_WheelEncoder),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wheelIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_WheelEncoder),
            "::",
            stringify!(wheelIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dataType) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_WheelEncoder),
            "::",
            stringify!(dataType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_WheelEncoder),
            "::",
            stringify!(data)
        )
    );
}
pub type sh2_WheelEncoder_t = sh2_WheelEncoder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sh2_SensorValue {
    #[doc = " Which sensor produced this event."]
    pub sensorId: u8,
    #[doc = " @brief 8-bit unsigned integer used to track reports.\n\n The sequence number increments once for each report sent.  Gaps\n in the sequence numbers indicate missing or dropped reports."]
    pub sequence: u8,
    #[doc = "< @brief bits 7-5: reserved, 4-2: exponent delay, 1-0: Accuracy"]
    pub status: u8,
    #[doc = "< [uS]"]
    pub timestamp: u64,
    #[doc = "< @brief [uS] value is delay * 2^exponent (see status)"]
    pub delay: u32,
    pub un: sh2_SensorValue__bindgen_ty_1,
}
#[doc = " @brief Sensor Data\n\n Use the structure based on the value of the sensor\n field."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union sh2_SensorValue__bindgen_ty_1 {
    pub rawAccelerometer: sh2_RawAccelerometer_t,
    pub accelerometer: sh2_Accelerometer_t,
    pub linearAcceleration: sh2_Accelerometer_t,
    pub gravity: sh2_Accelerometer_t,
    pub rawGyroscope: sh2_RawGyroscope_t,
    pub gyroscope: sh2_Gyroscope_t,
    pub gyroscopeUncal: sh2_GyroscopeUncalibrated_t,
    pub rawMagnetometer: sh2_RawMagnetometer_t,
    pub magneticField: sh2_MagneticField_t,
    pub magneticFieldUncal: sh2_MagneticFieldUncalibrated_t,
    pub rotationVector: sh2_RotationVectorWAcc_t,
    pub gameRotationVector: sh2_RotationVector_t,
    pub geoMagRotationVector: sh2_RotationVectorWAcc_t,
    pub pressure: sh2_Pressure_t,
    pub ambientLight: sh2_AmbientLight_t,
    pub humidity: sh2_Humidity_t,
    pub proximity: sh2_Proximity_t,
    pub temperature: sh2_Temperature_t,
    pub reserved: sh2_Reserved_t,
    pub tapDetector: sh2_TapDetector_t,
    pub stepDetector: sh2_StepDetector_t,
    pub stepCounter: sh2_StepCounter_t,
    pub sigMotion: sh2_SigMotion_t,
    pub stabilityClassifier: sh2_StabilityClassifier_t,
    pub shakeDetector: sh2_ShakeDetector_t,
    pub flipDetector: sh2_FlipDetector_t,
    pub pickupDetector: sh2_PickupDetector_t,
    pub stabilityDetector: sh2_StabilityDetector_t,
    pub personalActivityClassifier: sh2_PersonalActivityClassifier_t,
    pub sleepDetector: sh2_SleepDetector_t,
    pub tiltDetector: sh2_TiltDetector_t,
    pub pocketDetector: sh2_PocketDetector_t,
    pub circleDetector: sh2_CircleDetector_t,
    pub heartRateMonitor: sh2_HeartRateMonitor_t,
    pub arvrStabilizedRV: sh2_RotationVectorWAcc_t,
    pub arvrStabilizedGRV: sh2_RotationVector_t,
    pub gyroIntegratedRV: sh2_GyroIntegratedRV_t,
    pub izroRequest: sh2_IZroRequest_t,
    pub rawOptFlow: sh2_RawOptFlow_t,
    pub deadReckoningPose: sh2_DeadReckoningPose_t,
    pub wheelEncoder: sh2_WheelEncoder_t,
}
#[test]
fn bindgen_test_layout_sh2_SensorValue__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SensorValue__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorValue__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(sh2_SensorValue__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorValue__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sh2_SensorValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawAccelerometer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rawAccelerometer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accelerometer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(accelerometer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linearAcceleration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(linearAcceleration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gravity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gravity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawGyroscope) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rawGyroscope)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gyroscope) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gyroscope)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gyroscopeUncal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gyroscopeUncal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawMagnetometer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rawMagnetometer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magneticField) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(magneticField)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magneticFieldUncal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(magneticFieldUncal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rotationVector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rotationVector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gameRotationVector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gameRotationVector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).geoMagRotationVector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(geoMagRotationVector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ambientLight) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(ambientLight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).humidity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(humidity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proximity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(proximity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tapDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(tapDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stepDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stepDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stepCounter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stepCounter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sigMotion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(sigMotion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stabilityClassifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stabilityClassifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shakeDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(shakeDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flipDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(flipDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pickupDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(pickupDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stabilityDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(stabilityDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).personalActivityClassifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(personalActivityClassifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sleepDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(sleepDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tiltDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(tiltDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pocketDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(pocketDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).circleDetector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(circleDetector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heartRateMonitor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(heartRateMonitor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arvrStabilizedRV) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(arvrStabilizedRV)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arvrStabilizedGRV) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(arvrStabilizedGRV)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gyroIntegratedRV) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(gyroIntegratedRV)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).izroRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(izroRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawOptFlow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(rawOptFlow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deadReckoningPose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(deadReckoningPose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wheelEncoder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue__bindgen_ty_1),
            "::",
            stringify!(wheelEncoder)
        )
    );
}
#[test]
fn bindgen_test_layout_sh2_SensorValue() {
    const UNINIT: ::core::mem::MaybeUninit<sh2_SensorValue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sh2_SensorValue>(),
        80usize,
        concat!("Size of: ", stringify!(sh2_SensorValue))
    );
    assert_eq!(
        ::core::mem::align_of::<sh2_SensorValue>(),
        8usize,
        concat!("Alignment of ", stringify!(sh2_SensorValue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensorId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(sensorId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).un) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sh2_SensorValue),
            "::",
            stringify!(un)
        )
    );
}
pub type sh2_SensorValue_t = sh2_SensorValue;
extern "C" {
    pub fn sh2_decodeSensorEvent(
        value: *mut sh2_SensorValue_t,
        event: *const sh2_SensorEvent_t,
    ) -> ::core::ffi::c_int;
}
pub const shtp_Event_e_SHTP_SHORT_FRAGMENT: shtp_Event_e = 1;
pub const shtp_Event_e_SHTP_TOO_LARGE_PAYLOADS: shtp_Event_e = 2;
pub const shtp_Event_e_SHTP_BAD_RX_CHAN: shtp_Event_e = 3;
pub const shtp_Event_e_SHTP_BAD_TX_CHAN: shtp_Event_e = 4;
pub const shtp_Event_e_SHTP_BAD_FRAGMENT: shtp_Event_e = 5;
pub const shtp_Event_e_SHTP_BAD_SN: shtp_Event_e = 6;
pub const shtp_Event_e_SHTP_INTERRUPTED_PAYLOAD: shtp_Event_e = 7;
pub type shtp_Event_e = ::core::ffi::c_int;
pub use self::shtp_Event_e as shtp_Event_t;
pub type shtp_Callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::core::ffi::c_void,
        payload: *mut u8,
        len: u16,
        timestamp: u32,
    ),
>;
pub type shtp_EventCallback_t = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut ::core::ffi::c_void, shtpEvent: shtp_Event_t),
>;
extern "C" {
    pub fn shtp_open(pHal: *mut sh2_Hal_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn shtp_close(pShtp: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn shtp_setEventCallback(
        pInstance: *mut ::core::ffi::c_void,
        eventCallback: shtp_EventCallback_t,
        eventCookie: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn shtp_listenChan(
        pShtp: *mut ::core::ffi::c_void,
        channel: u8,
        callback: shtp_Callback_t,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn shtp_send(
        pShtp: *mut ::core::ffi::c_void,
        channel: u8,
        payload: *const u8,
        len: u16,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn shtp_service(pShtp: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn q_to_yaw(r: f32, i: f32, j: f32, k: f32) -> f32;
}
extern "C" {
    pub fn q_to_pitch(r: f32, i: f32, j: f32, k: f32) -> f32;
}
extern "C" {
    pub fn q_to_roll(r: f32, i: f32, j: f32, k: f32) -> f32;
}
extern "C" {
    pub fn q_to_ypr(
        r: f32,
        i: f32,
        j: f32,
        k: f32,
        pRoll: *mut f32,
        pPitch: *mut f32,
        pYaw: *mut f32,
    );
}
